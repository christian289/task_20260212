# 구현 완료 후 종합 검토

> 검토일: 2026-02-14
> 대상: feature/verification-fixes PR #6 merge 후 전체 프로젝트
> 검토 요청: 남은 요구사항, 에러 핸들링/로깅 보완점, SQLite 동시성, 사이드이펙트, 오버엔지니어링 여부

---

## 1. 남은 요구사항 점검

### 필수 요구사항 (과제 조건.md)

| 요구사항 | 상태 | 구현 위치 |
|----------|------|-----------|
| 직원 기본 연락 정보 조회 (GET 목록) | ✅ | `GET /api/employee?page=&pageSize=` |
| 직원 이름 검색 (GET 상세) | ✅ | `GET /api/employee/{name}` |
| CSV 파일 업로드 | ✅ | `POST /api/employee` (multipart/form-data + .csv) |
| JSON 파일 업로드 | ✅ | `POST /api/employee` (multipart/form-data + .json) |
| CSV body 직접 입력 | ✅ | `POST /api/employee` (text/csv) |
| JSON body 직접 입력 | ✅ | `POST /api/employee` (application/json) |
| CQRS 패턴 형태 코드 | ✅ | `Queries/`, `Commands/` 폴더 분리 + Handler 인터페이스 |
| 성공/실패 테스트 코드 | ✅ | 26개 (통합 16 + Mock 4 + Bogus 6) |

### 선택 요구사항

| 요구사항 | 상태 | 구현 위치 |
|----------|------|-----------|
| 로그 기능 | ✅ | 구조적 로깅 (BeginScope + 4단계 레벨 + 템플릿) |
| OpenAPI 명세 | ✅ | Scalar UI (`/scalar/v1`) |
| 설계 변경 용이한 코드 | ✅ | 인터페이스 기반 DI + 전략 패턴 (파서) + ErrorOr |

### 결론: 남은 요구사항 없음

---

## 2. 에러 핸들링 및 로깅 보완점

### 현재 구현 상태

| 계층 | 에러 처리 | 로깅 |
|------|-----------|------|
| Endpoint (Program.cs) | ErrorOr `.Match()` 패턴 + 전역 예외 핸들러 | `BeginScope` + Debug/Info/Warning |
| Command Handler | ErrorOr 반환 + FluentValidation | Debug/Info/Warning/Error |
| Query Handler | ErrorOr 반환 (NotFound 등) | Debug |
| Parser | ErrorOr 반환 + try-catch | Debug/Error |
| Repository | ErrorOr 반환 + try-catch | Debug/Info/Warning/Error |

### 검토 결과

- **전역 예외 핸들러**: `UseExceptionHandler`에서 예외 자체를 직접 로깅하지 않으나, ASP.NET Core 미들웨어가 내부적으로 자동 로깅하므로 실질적 문제 없음
- **ErrorOr 적용 범위**: 모든 Handler/Parser/Repository가 ErrorOr 반환으로 통일되어 예외 기반 흐름 제어 없음
- **로그 레벨 배분**: Debug(내부 처리), Information(비즈니스 완료), Warning(복구 가능 문제), Error(실패/예외) 적절히 분배됨
- **구조적 로깅**: 모든 로그가 템플릿 패턴 사용 (문자열 보간 없음), PascalCase 플레이스홀더

### 결론: 추가 보완 불필요. 현재 수준으로 충분.

---

## 3. SQLite 동시성 문제

### 발견된 문제: EnsureColumns ALTER TABLE 레이스 컨디션

**위치**: `SqliteEmployeeRepository.cs:154-175`

**시나리오**:
```
요청 A: GetExistingColumns() → "Department" 컬럼 없음
요청 B: GetExistingColumns() → "Department" 컬럼 없음
요청 A: ALTER TABLE ADD COLUMN "Department" → 성공
요청 B: ALTER TABLE ADD COLUMN "Department" → ❌ "duplicate column name" 예외
```

**원인**: 컬럼 존재 여부 확인(READ)과 컬럼 추가(WRITE)가 원자적이지 않음. SQLite WAL 모드에서도 이 READ-then-WRITE 패턴은 보호되지 않음.

**영향**: ExtraFields가 포함된 동시 POST 요청에서만 발생. 기본 CSV/JSON (Name, Email, Tel, Joined만)에서는 발생하지 않음.

### 적용된 수정

`EnsureColumns` 내 ALTER TABLE을 try-catch로 감싸 "duplicate column" 예외를 무시:

```csharp
try
{
    alterCmd.ExecuteNonQuery();
    _logger.LogInformation("동적 컬럼 추가: {ColumnName}", col);
}
catch (SqliteException ex) when (ex.Message.Contains("duplicate column"))
{
    _logger.LogDebug("컬럼 이미 존재 (동시 요청): {ColumnName}", col);
}
```

**커밋**: `5331a8c` — 수정: EnsureColumns ALTER TABLE 동시성 레이스 컨디션 방어

### 기타 동시성 특성

- SQLite WAL 모드: 동시 읽기 + 단일 쓰기 직렬화 → 기본적인 동시성 보장
- Connection per operation: 각 메서드가 별도 연결 생성/소멸 → SQLite에서 적절한 패턴
- Singleton Repository: 상태 없음 (connection string만 보유) → 스레드 안전

---

## 4. 예상 사이드이펙트

### 4-1. 부분 성공 시 실패 건 정보 미반환 (의도적 설계)

- **상황**: 5명 제출 → 3명 FluentValidation 실패 → 2명만 저장
- **응답**: 201 Created + 2명 데이터 반환
- **문제**: 호출자는 어떤 직원이 왜 거부됐는지 응답에서 알 수 없음
- **완화**: 실패 상세는 Debug 로그에 기록됨 (`검증 실패 [{Index}]: {Property} - {Message}`)
- **판단**: 과제 범위에서 수용 가능. 실무에서는 `warnings` 필드 추가 고려

### 4-2. 에러 응답 포맷 변경

- **이전**: `{"message":"Employee 'xxx' not found."}`
- **이후**: `{"errors":[{"code":"Employee.NotFound","description":"'xxx' 이름의 직원을 찾을 수 없습니다."}]}`
- **영향**: 프론트엔드가 아직 없으므로 호환성 문제 없음. 오히려 구조화된 에러 코드가 프론트엔드 연동에 유리

### 4-3. FluentValidation 검증 강화로 인한 거부 범위 확대

- **이전**: 파싱 성공하면 어떤 형식이든 저장 (이메일 형식 무관, 전화번호 형식 무관)
- **이후**: `not-an-email` → 거부, `12345` → 거부, 빈 이름 → 거부
- **판단**: 의도된 동작. 데이터 정합성 강화.

---

## 5. 오버엔지니어링 여부

### 판정표

| 추가 요소 | 판정 | 근거 |
|-----------|------|------|
| ErrorOr 라이브러리 | ✅ 적절 | 실무 에러 처리 패턴, 면접 평가 기준(예외 처리)에 직접 기여 |
| FluentValidation | ✅ 적절 | .NET 표준 검증 라이브러리, 데이터 정합성 보장 |
| 구조적 로깅 (BeginScope) | ✅ 적절 | [선택] 요구사항 충족 + 실무 수준 시연 |
| 전역 예외 핸들러 | ✅ 적절 | 보안 기본 (스택 트레이스 노출 방지) |
| pageSize 상한 100 | ✅ 적절 | 방어적 프로그래밍 1줄, 비용 없음 |
| Kestrel 10MB 제한 | ⚪ 경계선 | 있으면 좋지만 필수 아님 (1줄이라 비용 없음) |
| 부분 성공 패턴 | ⚪ 경계선 | 복잡도 약간 증가, 실무적 판단력 시연 |

### 결론: 오버엔지니어링 없음

모든 추가 요소가 과제 평가 기준(코딩 습관, 예외 처리, 코드 구조, 테스트)에 직접 기여하며, 과도한 추상화나 불필요한 레이어 없음.

---

## 최종 요약

| 관점 | 결론 |
|------|------|
| 요구사항 | ✅ 필수/선택 전부 충족. 남은 것 없음 |
| 에러 핸들링/로깅 | ✅ 충분. 추가 보완 불필요 |
| 동시성 | ✅ 레이스 컨디션 수정 완료 (`5331a8c`) |
| 사이드이펙트 | ℹ️ 부분 성공 미반환, 응답 포맷 변경 — 모두 수용 가능 |
| 오버엔지니어링 | ✅ 없음. 모든 추가 요소가 평가 기준에 기여 |
